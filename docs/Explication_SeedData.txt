
======================================================================
ISFCE â€“ PROJET DISPENSES 25â€“26
DOCUMENT : EXPLICATION DE LA CLASSE SeedData
======================================================================

ğŸŒ± Lâ€™idÃ©e gÃ©nÃ©rale
----------------------------------------------------------------------
La classe SeedData sert Ã  initialiser automatiquement des donnÃ©es de base dans lâ€™application au dÃ©marrage.
On appelle Ã§a du â€œseedingâ€ (ensemencement), câ€™est-Ã -dire : â€œmettre un petit jeu de donnÃ©es de dÃ©part pour tester lâ€™applicationâ€.

ğŸ‘‰ Ici, elle :
- crÃ©e quelques UE ISFCE de base (cours officiels),
- et ajoute quelques rÃ¨gles de correspondance entre des cours externes et les UE de lâ€™Ã©cole (via ExemptionService).

Bref, câ€™est ton petit script dâ€™initialisation automatique, lancÃ© au dÃ©marrage de Spring Boot.

----------------------------------------------------------------------
âš™ï¸ Les annotations et le rÃ´le de la classe
----------------------------------------------------------------------
@Configuration
public class SeedData {

@Configuration indique Ã  Spring que cette classe contient des beans Ã  instancier au dÃ©marrage.
â†’ Autrement dit : câ€™est une classe de configuration, pas une entitÃ© mÃ©tier.

----------------------------------------------------------------------
ğŸŒ¾ Le cÅ“ur du fichier : le @Bean ApplicationRunner
----------------------------------------------------------------------
@Bean
ApplicationRunner runner(UEIsfceRepository ueRepo, ExemptionService svc) {
    return args -> {
        ...
    };
}

### Quâ€™est-ce que ApplicationRunner ?
Câ€™est une fonction spÃ©ciale fournie par Spring Boot :
tout ce qui est dÃ©fini dans un ApplicationRunner sâ€™exÃ©cute automatiquement juste aprÃ¨s le dÃ©marrage de lâ€™application, quand tout est prÃªt (contexte Spring, base de donnÃ©es, services, etc.).

En clair :
â€œQuand lâ€™app dÃ©marre, exÃ©cute ce bout de code une fois.â€

----------------------------------------------------------------------
ğŸ§± Le contenu du runner
----------------------------------------------------------------------
if (ueRepo.count() == 0) {
    ueRepo.save(UEIsfce.builder().code("IPDB").libelle("Intro Prog & DB").ects(5).build());
    ueRepo.save(UEIsfce.builder().code("ALG1").libelle("Algorithmes 1").ects(4).build());
    ueRepo.save(UEIsfce.builder().code("WEB1").libelle("Web 1").ects(5).build());
}

ğŸ’¡ RÃ´le :
- VÃ©rifie si la table ue_isfce est vide (count() == 0).
- Si oui, il ajoute trois UE de base :
  - IPDB â†’ Intro Prog & DB (5 ECTS)
  - ALG1 â†’ Algorithmes 1 (4 ECTS)
  - WEB1 â†’ Web 1 (5 ECTS)

â¡ï¸ Ces donnÃ©es sont sauvegardÃ©es via le repository UEIsfceRepository.

Pourquoi ce if ?
â†’ Pour Ã©viter de les recrÃ©er Ã  chaque redÃ©marrage : la condition empÃªche les doublons.

----------------------------------------------------------------------
ğŸ§  DeuxiÃ¨me partie : les rÃ¨gles â€œauto-matchâ€
----------------------------------------------------------------------
// RÃ¨gles simples : (Ã©tablissement, code externe) -> code UE ISFCE
svc.seedRule("ULB", "INFO101", "IPDB");
svc.seedRule("ULB", "ALG-BASE", "ALG1");
svc.seedRule("HE2B", "WDEV-101", "WEB1");

ğŸ’¡ RÃ´le :
Ici, on appelle la mÃ©thode seedRule(...) du ExemptionService.
Elle remplit la petite â€œbase de connaissancesâ€ interne du service (une Map<String, String> appelÃ©e kb).

Autrement dit :
â€œSi un Ã©tudiant de lâ€™ULB a suivi le cours INFO101, câ€™est Ã©quivalent Ã  notre UE IPDB.â€
â€œSi lâ€™ULB propose ALG-BASE, Ã§a correspond Ã  ALG1.â€
â€œSi la HE2B propose WDEV-101, câ€™est pareil que WEB1.â€

Cela permet Ã  lâ€™application dâ€™Ãªtre un peu â€œintelligenteâ€ dÃ¨s le dÃ©part :
quand un Ã©tudiant soumettra une demande, lâ€™auto-matching fonctionnera dÃ©jÃ .

----------------------------------------------------------------------
ğŸ” RÃ©sumÃ© du flux dâ€™exÃ©cution au dÃ©marrage
----------------------------------------------------------------------
1ï¸âƒ£ Lâ€™app dÃ©marre.
2ï¸âƒ£ Spring dÃ©tecte cette classe @Configuration.
3ï¸âƒ£ Il exÃ©cute la mÃ©thode runner(...).
4ï¸âƒ£ Le code vÃ©rifie sâ€™il y a des UE existantes :
   - Si non â†’ crÃ©e 3 cours ISFCE en base.
5ï¸âƒ£ Il configure les rÃ¨gles de correspondance dans le service (seedRule).
6ï¸âƒ£ Ton application dÃ©marre avec un jeu de donnÃ©es dÃ©jÃ  prÃªt Ã  lâ€™emploi.

----------------------------------------------------------------------
ğŸ§© Pourquoi câ€™est utile
----------------------------------------------------------------------
âœ… Gain de temps : pas besoin dâ€™ajouter manuellement des donnÃ©es Ã  chaque test.
âœ… CohÃ©rence : tout le monde a les mÃªmes donnÃ©es de base (utile pour les collÃ¨gues ou les tests automatisÃ©s).
âœ… TestabilitÃ© : tu peux lancer ton appli et directement tester le front ou les appels API.
âœ… Ã‰volutif : tu peux facilement ajouter dâ€™autres cours ou mappings plus tard.

----------------------------------------------------------------------
ğŸ§± En rÃ©sumÃ© visuel
----------------------------------------------------------------------
Ã‰lÃ©ment | Type | RÃ´le
----------|------|------
@Configuration | Annotation | Indique que la classe contient de la config Ã  charger au dÃ©marrage
@Bean ApplicationRunner | MÃ©thode | Code exÃ©cutÃ© une fois au lancement de lâ€™app
ueRepo.count() == 0 | VÃ©rification | Ã‰vite de dupliquer les UE si elles existent dÃ©jÃ 
ueRepo.save(...) | Action | Ajoute 3 UE de base en base H2
svc.seedRule(...) | Action | Ajoute des rÃ¨gles dâ€™Ã©quivalence entre cours externes et UE internes

----------------------------------------------------------------------
ğŸ§  Ã€ propos du dÃ©marrage de lâ€™application
----------------------------------------------------------------------
Le ApplicationRunner ne perturbe pas le SpringApplication.run de ta classe principale.
Il est exÃ©cutÃ© aprÃ¨s le dÃ©marrage du contexte Spring, sans bloquer ni ralentir lâ€™application.

Flux dâ€™exÃ©cution :
1ï¸âƒ£ SpringApplication.run dÃ©marre lâ€™application.
2ï¸âƒ£ Spring charge tous les beans et la base H2.
3ï¸âƒ£ Le runner est exÃ©cutÃ© une seule fois.
4ï¸âƒ£ Lâ€™application est prÃªte Ã  lâ€™usage.

----------------------------------------------------------------------
ğŸ’¾ Persistance des donnÃ©es : mÃ©moire ou disque
----------------------------------------------------------------------
Dans ta configuration actuelle :
spring.datasource.url: jdbc:h2:mem:exempt;DB_CLOSE_DELAY=-1

â¡ï¸ La base est en mÃ©moire, donc elle disparaÃ®t Ã  chaque redÃ©marrage.
Le SeedData sâ€™exÃ©cute Ã  chaque lancement pour recrÃ©er les donnÃ©es.

Si tu veux garder les donnÃ©es :
spring.datasource.url: jdbc:h2:file:./data/exempt;DB_CLOSE_ON_EXIT=FALSE;AUTO_SERVER=TRUE

Type | URL JDBC | Persistance | Comportement
------|-----------|--------------|---------------
MÃ©moire | jdbc:h2:mem:exempt | DisparaÃ®t Ã  chaque arrÃªt | DonnÃ©es recrÃ©Ã©es Ã  chaque lancement
Fichier | jdbc:h2:file:./data/exempt | ConservÃ©e entre les runs | DonnÃ©es persistantes

----------------------------------------------------------------------
âœ… En rÃ©sumÃ© simple
----------------------------------------------------------------------
- SeedData est une classe dâ€™initialisation automatique.
- Elle est chargÃ©e au dÃ©marrage de lâ€™application.
- Elle ajoute des UE de base et des rÃ¨gles dâ€™Ã©quivalence.
- Elle ne sâ€™exÃ©cute quâ€™une fois si la table nâ€™est pas vide.
- Elle ne perturbe pas SpringApplication.run.
- En base H2 mÃ©moire, les donnÃ©es sont recrÃ©Ã©es Ã  chaque lancement.
- En base H2 fichier, les donnÃ©es sont conservÃ©es entre les redÃ©marrages.

ğŸŒ¿ En une phrase :
SeedData, câ€™est le petit jardinier automatique de ton application :
il plante les premiÃ¨res donnÃ©es dans ta base et sÃ¨me les correspondances
pour que tout fonctionne dÃ¨s le premier lancement ğŸŒ±

======================================================================
FIN DU DOCUMENT â€“ Ã€ COLLER DANS WORD ET METTRE LA POLICE Ã€ 8 PT
======================================================================
